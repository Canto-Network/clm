{"compiler":{"version":"0.8.11+commit.d7f03943"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token0","type":"address"},{"indexed":true,"internalType":"address","name":"token1","type":"address"},{"indexed":false,"internalType":"bool","name":"stable","type":"bool"},{"indexed":false,"internalType":"address","name":"pair","type":"address"},{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"PairCreated","type":"event"},{"inputs":[],"name":"acceptPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"admin","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"allPairs","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"allPairsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"createPair","outputs":[{"internalType":"address","name":"pair","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"getInitializable","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isPair","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pairCodeHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingPauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"admin_","type":"address"}],"name":"setAdmin","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_state","type":"bool"}],"name":"setPause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_pauser","type":"address"}],"name":"setPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newPeriod","type":"uint256"}],"name":"setPeriodSize","outputs":[],"stateMutability":"nonpayable","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"src/Swap/BaseV1-core.sol":"BaseV1Factory"},"evmVersion":"london","libraries":{":__CACHE_BREAKER__":"0x0000000000000031363630313837333733303434"},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"src/Swap/BaseV1-core.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./BaseV1-libs.sol\";\n\ninterface IBaseV1Callee {\n    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n\n// The base pair of pools, either stable or volatile\ncontract BaseV1Pair {\n\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\n    bool public immutable stable;\n\n    uint public totalSupply = 0;\n\n    mapping(address => mapping (address => uint)) public allowance;\n    mapping(address => uint) public balanceOf;\n\n    bytes32 internal DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    uint internal constant MINIMUM_LIQUIDITY = 10**3;\n\n    address public immutable token0;\n    address public immutable token1;\n    address immutable factory;\n\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint timestamp;\n        uint reserve0Cumulative;\n        uint reserve1Cumulative;\n        uint totalSupplyCumulative;\n    }\n\n    // Capture oracle reading every 30 minutes\n    uint public periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint internal immutable decimals0;\n    uint internal immutable decimals1;\n\n    uint public reserve0;\n    uint public reserve1;\n    uint public blockTimestampLast;\n\n    uint public reserve0CumulativeLast;\n    uint public reserve1CumulativeLast;\n    uint public totalSupplyCumulativeLast;\n\n\n    // position assigned to each LP to track their current index0 & index1 vs the global position\n    mapping(address => uint) public supplyIndex0;\n    mapping(address => uint) public supplyIndex1;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint reserve0, uint reserve1);\n    event Claim(address indexed sender, address indexed recipient, uint amount0, uint amount1);\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    constructor() {\n        factory = msg.sender;\n        (address _token0, address _token1, bool _stable) = BaseV1Factory(msg.sender).getInitializable();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        if (_stable) {\n            name = string(abi.encodePacked(\"StableV1 AMM - \", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"sAMM-\", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\n        } else {\n            name = string(abi.encodePacked(\"VolatileV1 AMM - \", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"vAMM-\", erc20(_token0).symbol(), \"/\", erc20(_token1).symbol()));\n        }\n\n        decimals0 = 10**erc20(_token0).decimals();\n        decimals1 = 10**erc20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0,0));\n    }\n\n    function setPeriodSize(uint periodSize_) external {\n        require(msg.sender == factory);\n        periodSize = periodSize_;\n    }\n\n\n    // simple re-entrancy check\n    uint internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function observationLength() external view returns (uint) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length-1];\n    }\n\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1) {\n        return (decimals0, decimals1, reserve0, reserve1, stable, token0, token1);\n    }\n\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    function getReserves() public view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint _reserve0, uint _reserve1) internal {\n        uint blockTimestamp = block.timestamp;\n        uint timeElapsed = blockTimestamp - blockTimestampLast;\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n            totalSupplyCumulativeLast += totalSupply * timeElapsed; //update totalSupply after each change in LP Token supply \n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > periodSize) {\n            observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast, totalSupplyCumulativeLast));\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices() public view returns (uint reserve0Cumulative, uint reserve1Cumulative, uint blockTimestamp) {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint _reserve0, uint _reserve1, uint _blockTimestampLast) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            uint timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint amountIn) external view returns (uint amountOut) {\n        Observation memory _observation = lastObservation();\n        (uint reserve0Cumulative, uint reserve1Cumulative,) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length-2];\n        }\n\n        uint timeElapsed = block.timestamp - _observation.timestamp;\n        uint _reserve0 = (reserve0Cumulative - _observation.reserve0Cumulative) / timeElapsed;\n        uint _reserve1 = (reserve1Cumulative - _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    // as per `current`, however allows user configured granularity, up to the full window size\n    function quote(address tokenIn, uint amountIn, uint granularity) external view returns (uint amountOut) {\n        uint [] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint priceAverageCumulative;\n        for (uint i = 0; i < _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    // returns a memory set of twap prices\n    function prices(address tokenIn, uint amountIn, uint points) external view returns (uint[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(address tokenIn, uint amountIn, uint points, uint window) public view returns (uint[] memory) {\n        uint[] memory _prices = new uint[](points);\n\n        uint lastIndex = observations.length-1;\n        \n        require(lastIndex >= points * window, \"PAIR::NOT READY FOR PRICING\"); //log if the price is requested and there are not enough observations\n        \n        uint i = lastIndex - (points * window); // point from which to begin the sample\n        uint nextIndex = 0;\n        uint index = 0;\n\n        for (; i < lastIndex; i+=window) {\n            nextIndex = i + window;\n            uint timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            uint _reserve0 = (observations[nextIndex].reserve0Cumulative - observations[i].reserve0Cumulative) / timeElapsed;\n            uint _reserve1 = (observations[nextIndex].reserve1Cumulative - observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n            index = index + 1;\n        }\n\n        return _prices;\n    }\n\n    function reserves(uint granularity) external view returns(uint, uint) {\n        (uint[] memory _reserves0, uint[] memory _reserves1)= sampleReserves(granularity, 1);\n        uint reserveAverageCumulative0;\n        uint reserveAverageCumulative1;\n\n        for (uint i = 0; i < _reserves0.length; ++i) {\n            reserveAverageCumulative0 += _reserves0[i]; //normalize the reserves for TWAP LP Oracle pricing, \n            reserveAverageCumulative1 += _reserves1[i]; //\n        }\n\n        return (reserveAverageCumulative0 / granularity, reserveAverageCumulative1 / granularity);\n    }\n\n    function sampleReserves(uint points, uint window) public view returns (uint[] memory, uint[] memory) {\n        uint[] memory _reserves0 = new uint[](points);\n        uint[] memory _reserves1 = new uint[](points);\n        \n        uint lastIndex = observations.length-1;\n        require(lastIndex >= points * window, \"PAIR::NOT READY FOR PRICING\");\n        uint i = lastIndex - (points * window); // point from which to begin the sample\n        uint nextIndex = 0;\n        uint index = 0;\n        uint timeElapsed;\n\n        for(; i < lastIndex; i+=window) {\n            nextIndex = i + window;\n            timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            _reserves0[index] = (observations[nextIndex].reserve0Cumulative - observations[i].reserve0Cumulative) / timeElapsed;\n            _reserves1[index] = (observations[nextIndex].reserve1Cumulative - observations[i].reserve1Cumulative) / timeElapsed;\n            \n            index = index + 1;\n        }\n\n        return (_reserves0, _reserves1);\n    }\n\n    function totalSupplyAvg(uint granularity) external view returns(uint) {\n        uint[] memory _totalSupplyAvg = sampleSupply(granularity, 1);\n        uint totalSupplyCumulativeAvg;\n\n        for (uint i = 0; i < _totalSupplyAvg.length; ++i) {\n            totalSupplyCumulativeAvg += _totalSupplyAvg[i]; //totalSupply denominated in terms of 1e18 \n        }\n\n        return (totalSupplyCumulativeAvg / granularity);\n    }\n\n    function sampleSupply(uint points, uint window) public view returns (uint[] memory) {\n        uint[] memory _totalSupply = new uint[](points);\n        \n        uint lastIndex = observations.length-1;\n        require(lastIndex >= points * window, \"PAIR::NOT READY FOR PRICING\");\n        uint i = lastIndex - (points * window); // point from which to begin the sample\n        uint nextIndex = 0;\n        uint index = 0;\n        uint timeElapsed;\n\n        for(; i < lastIndex; i+=window) {\n            nextIndex = i + window;\n            timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            _totalSupply[index] = (observations[nextIndex].totalSupplyCumulative - observations[i].totalSupplyCumulative) / timeElapsed;\n            index = index + 1;\n        }\n\n        return _totalSupply;\n    }\n\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function mint(address to) external lock returns (uint liquidity) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        uint _balance0 = erc20(token0).balanceOf(address(this));\n        uint _balance1 = erc20(token1).balanceOf(address(this));\n        uint _amount0 = _balance0 - _reserve0;\n        uint _amount1 = _balance1 - _reserve1;\n\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        \n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(_amount0 * _totalSupply / _reserve0, _amount1 * _totalSupply / _reserve1);\n        }\n\n        require(liquidity > 0, \"ILM\"); // BaseV1: INSUFFICIENT_LIQUIDITY_MINTED\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function burn(address to) external lock returns (uint amount0, uint amount1) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint _balance0 = erc20(_token0).balanceOf(address(this));\n        uint _balance1 = erc20(_token1).balanceOf(address(this));\n        uint _liquidity = balanceOf[address(this)];\n\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = _liquidity * _balance0 / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = _liquidity * _balance1 / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"ILB\"); // BaseV1: INSUFFICIENT_LIQUIDITY_BURNED\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        _balance0 = erc20(_token0).balanceOf(address(this));\n        _balance1 = erc20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\n        require(!BaseV1Factory(factory).isPaused());\n        require(amount0Out > 0 || amount1Out > 0, \"IOA\"); // BaseV1: INSUFFICIENT_OUTPUT_AMOUNT\n        (uint _reserve0, uint _reserve1) =  (reserve0, reserve1);\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"IL\"); // BaseV1: INSUFFICIENT_LIQUIDITY\n\n        uint _balance0;\n        uint _balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        (address _token0, address _token1) = (token0, token1);\n        require(to != _token0 && to != _token1, \"IT\"); // BaseV1: INVALID_TO\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IBaseV1Callee(to).hook(msg.sender, amount0Out, amount1Out, data); // callback, used for flash loans\n        _balance0 = erc20(_token0).balanceOf(address(this));\n        _balance1 = erc20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = _balance0 > _reserve0 - amount0Out ? _balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = _balance1 > _reserve1 - amount1Out ? _balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"IIA\"); // BaseV1: INSUFFICIENT_INPUT_AMOUNT\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        (address _token0, address _token1) = (token0, token1);\n        _balance0 = erc20(_token0).balanceOf(address(this));\n        // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n        _balance1 = erc20(_token1).balanceOf(address(this));\n        // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n        require(_k(_balance0, _balance1) >= _k(_reserve0, _reserve1), \"K\"); // BaseV1: K\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        _safeTransfer(_token0, to, erc20(_token0).balanceOf(address(this)) - (reserve0));\n        _safeTransfer(_token1, to, erc20(_token1).balanceOf(address(this)) - (reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(erc20(token0).balanceOf(address(this)), erc20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    function _f(uint x0, uint y) internal pure returns (uint) {\n        return x0*(y*y/1e18*y/1e18)/1e18+(x0*x0/1e18*x0/1e18)*y/1e18;\n    }\n\n    function _d(uint x0, uint y) internal pure returns (uint) {\n        return 3*x0*(y*y/1e18)/1e18+(x0*x0/1e18*x0/1e18);\n    }\n\n    function _get_y(uint x0, uint xy, uint y) internal pure returns (uint) {\n        for (uint i = 0; i < 255; i++) {\n            uint y_prev = y;\n            uint k = _f(x0, y);\n            if (k < xy) {\n                uint dy = (xy - k)*1e18/_d(x0, y);\n                y = y + dy;\n            } else {\n                uint dy = (k - xy)*1e18/_d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(uint amountIn, address tokenIn) external view returns (uint) {\n        (uint _reserve0, uint _reserve1) = (reserve0, reserve1);\n        //amountIn -= amountIn / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(uint amountIn, address tokenIn, uint _reserve0, uint _reserve1) internal view returns (uint) {\n        if (stable) {\n            uint xy =  _k(_reserve0, _reserve1);\n            _reserve0 = _reserve0 * 1e18 / decimals0;\n            _reserve1 = _reserve1 * 1e18 / decimals1;\n            (uint reserveA, uint reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0 ? amountIn * 1e18 / decimals0 : amountIn * 1e18 / decimals1;\n            uint y = reserveB - _get_y(amountIn+reserveA, xy, reserveB);\n            return y * (tokenIn == token0 ? decimals1 : decimals0) / 1e18;\n        } else {\n            (uint reserveA, uint reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            return amountIn * reserveB / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint x, uint y) public view returns (uint) {\n        if (stable) {\n            uint _x = x * 1e18 / decimals0;\n            uint _y = y * 1e18 / decimals1;\n            uint _a = (_x * _y) / 1e18;\n            uint _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return _a * _b / 1e18;  // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    function _mint(address dst, uint amount) internal {\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint amount) internal {\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"BaseV1: EXPIRED\");\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"BaseV1: INVALID_SIGNATURE\");\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint amount) external returns (bool) {\n        address spender = msg.sender;\n        uint spenderAllowance = allowance[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint).max) {\n            uint newAllowance = spenderAllowance - amount;\n            allowance[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(address src, address dst, uint amount) internal {\n        balanceOf[src] -= amount;\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(erc20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n\ncontract BaseV1Factory {\n\n    bool public isPaused;\n    address public pauser;\n    address public pendingPauser;\n    address public admin;\n    uint MaxPeriod = 3600;\n\n    mapping(address => mapping(address => mapping(bool => address))) public getPair;\n    address[] public allPairs;\n    mapping(address => bool) public isPair; // simplified check if its a pair, given that `stable` flag might not be available in peripherals\n\n    address internal _temp0;\n    address internal _temp1;\n    bool internal _temp;\n\n    event PairCreated(address indexed token0, address indexed token1, bool stable, address pair, uint);\n\n    constructor() {\n        pauser = msg.sender;\n        isPaused = false;\n        admin = msg.sender;\n    }\n\n    // admin for setting the periodSize in pairs\n    function setAdmin(address admin_) external {\n        require(msg.sender == admin);\n        admin = admin_;\n    }\n\n    function setPeriodSize(uint newPeriod) external {\n        require(msg.sender == admin);\n        require(newPeriod <= MaxPeriod);\n\n        for (uint i; i < allPairs.length; ) {\n            BaseV1Pair(allPairs[i]).setPeriodSize(newPeriod);\n            unchecked {++i;}\n        }\n    }\n\n\n    function allPairsLength() external view returns (uint) {\n        return allPairs.length;\n    }\n\n    function setPauser(address _pauser) external {\n        require(msg.sender == pauser);\n        pendingPauser = _pauser;\n    }\n\n    function acceptPauser() external {\n        require(msg.sender == pendingPauser);\n        pauser = pendingPauser;\n    }\n\n    function setPause(bool _state) external {\n        require(msg.sender == pauser);\n        isPaused = _state;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(BaseV1Pair).creationCode);\n    }\n\n    function getInitializable() external view returns (address, address, bool) {\n        return (_temp0, _temp1, _temp);\n    }\n\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair) {\n        require(tokenA != tokenB, \"IA\"); // BaseV1: IDENTICAL_ADDRESSES\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), \"ZA\"); // BaseV1: ZERO_ADDRESS\n        require(getPair[token0][token1][stable] == address(0), \"PE\"); // BaseV1: PAIR_EXISTS - single check is sufficient\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters\n        (_temp0, _temp1, _temp) = (token0, token1, stable);\n        pair = address(new BaseV1Pair{salt:salt}());\n        getPair[token0][token1][stable] = pair;\n        getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        isPair[pair] = true;\n        emit PairCreated(token0, token1, stable, pair, allPairs.length);\n    }\n}\n","keccak256":"0x7f78b45e70ecdd7091280ad2cbabca621f5468d8d2be44f2c20d0a3b5959e8f5","license":"MIT"},"src/Swap/BaseV1-libs.sol":{"content":"pragma solidity 0.8.11;\n\n\ninterface erc20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint value) external returns (bool);\n}\n\nlibrary Math {\n    function min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}","keccak256":"0x1e9bf0b17252bc691a6798415a032687444bf32ab2942777fd2f697225874cab"}},"version":1}